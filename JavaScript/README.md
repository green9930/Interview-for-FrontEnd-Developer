# Index

[1. 자바스크립트란](#자바스크립트란)  
[2. 변수 (variable)](#변수-variable)  
[3. 데이터 타입](#데이터-타입)  
[4. 단축 평가](#단축-평가)
[5. 객체](#객체)
[6. 함수](#함수)

---

# 자바스크립트란

## 자바스크립트 렌더링

HTML, CSS, JavaScript등 문서를 해석해서 브라우저에 시각적으로 출력하는 것

### 서버 사이드 렌더링 (Server Side Rendering)

요청을 받으면 서버에서 요청받은 페이지의 HTML 파일을 렌더링한 뒤 이용자에게 반환하는 방식  

- 장점
  1. SEO(Search Engine Optimization, 검색엔진 최적화)가 가능하다.
  2. 사용자가 보는 페이지만 렌더링해서 전달하기 때문에 초기 로딩 속도가 CSR에 비해 빠르다.  

- 단점
  1. 페이지를 이동할 때마다 요청을 보내고 서버는 해당 페이지 전체를 렌더링하기 때문에 트래픽이 증가한다.
  2. 페이지 이동 시 화면이 깜빡거리는 문제가 있다.
  3. 프로젝트의 복잡도가 증가한다.  

### 클라이언트 사이드 렌더링 (Client Side Rendering)

최초 요청을 받으면 서버에서 전체 페이지를 로딩해서 반환하는 방식  

- 장점
  1. 최초 요청 이후 서버에 재요청 없이 DOM 조작으로 필요한 부분만 받기 때문에 빠른 인터렉션이 가능하다.  

- 단점
  1. 최초 요청 시 모든 페이지를 받기 때문에 첫 로딩 속도가 느리다.
  2. 검색 엔진은 자바스크립트를 실행하지 않기 때문에 브라우저의 검색 엔진 시점에서 SPA의 페이지는 비어있는 상태이다. 따라서 SEO 문제가 발생한다.  

## 자바스크립트와 Ajax

**Ajax** : (Asynchronous JavaScript And XML)
- 자바스크립트로 서버와 클라이언트가 비동기적으로 데이터를 전송하고 화면을 구현하는 방식
- 웹페이지에서 변경이 불필요한 부분을 제외하고 서버로부터 필요한 데이터만 전달받아 리렌더링 된다.
- 기존에는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 작동했다. 따라서 HTML 코드 일부가 수정되면 변경되지 않은 부분까지 모두 리렌더링되는 비효율적인 측면이 있었고, Ajax를 통해 이 단점을 보완할 수 있었다.  

## V8 자바스크립트 엔진

- V8 자바스크립트 엔진의 등장으로 브라우저에서 자바스크립트 코드를 빠르게 실행할 수 있게 되었고 이로 인해 과거 웹 서버에서 수행되던 로직의 다수가 브라우저로 이동하면서 프론트엔드 영역이 주목받는 계기가 되었다.  

## ECMAScript

## 자바스크립트의 특징

- 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (interpreter language)
  - 인터프리터 언어 : 코드가 실행되는 런타임에 한 줄씩 바이트코드로 변환하여 실행
- 명령형(imperactive), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**
  - 명령형 : "무엇을 어떻게(how) 할 것인가"  

## 라이브러리를 사용하는 이유

- 라이브러리가 DOM 엘리먼트를 관리해주기 때문에 개발자는 상태관리(=기능 개발)에만 집중할 수 있다.  

## 리액트를 사용하는 이유

컴포넌트 단위로 구성 -> 컴포넌트 일괄 수정
유지보수, 생산성 용이
JSX를 제공하기 때문 : HTML을 알아도
Virtual DOM : 리액트에서 가장 성공적으로 적용

---

# 변수 (variable)

## 변수란 무엇인가? 왜 필요한가?

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 (값의 위치를 가리키는 상징적인 이름)
- 저장된 값은 메모리 공간에 저장되고, 이를 재사용하기 위해 메모리 공간에 사람이 이해할 수 있는 언어로 상징적인 이름을 붙인 것이 변수이다.  

## 변수 선언(variable declaration) 이란?

- 변수 선언 : 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간 주소를 연결해서 값을 저장할 수 있도록 준비하는 것
- 변수는 메모리에 저장된 **값**이 아니라 **메모리 주소**를 기억한다.  

## 변수 선언 방식

### var

```js
var result;
```

- ES6 이전 변수 선언 방식
- 변수 선언만 할 경우 자바스크립트 엔진은 확보된 메모리 공간에 `undefined`를 암묵적으로 할당하여 초기화한다.
- 단점 : 블록 레벨 스코프가 아닌 함수 레벨 스코프를 지원 -> 변수 호이스팅 문제 발생

**변수 호이스팅**

```js
console.log(result); // undefined
var result;
result = 10;
console.log(result); // 10
```

변수 호이스팅은 왜 발생할까?

- 자바스크립트는 런타임 이전에 코드를 평가하는 과정을 거친다. 이 과정에서 변수 선언이 먼저 평가되고, var 키워드의 경우 변수 선언과 초기화가 동시에 이루어지기 때문에 런타임에 `console.log(result)`에서 `undefined`가 출력되는 것이다.

### let

- ES6 이후 등장한 변수 선언 방식

### const

- 단 한 번만 할당할 수 있는 변수, 즉 상수를 선언하는 키워드
- const 키워드로 선언된 변수는 재할당이 금지된다.

## 가비지 콜렉터

가비지 콜렉터의 알고리즘 : **Mark and Sweep algorithm**
자바스크립트는 managed language (C언어등은 unmanaged language : 개발자가 직접 메모리를 해제해야 한다.)

1. Mark phase

- GC Root(가비지 콜렉터의 루트)로부터 시작해 이 루트가 참조하는 모든 오브젝트를 마크한다.

2. Sweep phase

- 마크가 끝나면 가비지 콜렉터는 메모리 전체를 돌면서 마크되지 않은 메모리를 해제한다.

---

# 데이터 타입

## 데이터 타입의 종류 (자료형)

- 원시 타입 (primitive type)
  1. 숫자 타입
    - 다른 언어는 다양한 숫자타입이 있으나 자바스크립트는 number 하나만 존재한다. (모든 수를 실수로 처리한다.)
  2. 문자열 타입
  3. 불리언 타입
  4. undefined 타입
  5. null 타입
  6. symbol 타입

7. 객체 타입 : 객체, 함수, 배열 등

**undefined와 null의 차이점**

- undefined : 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값 (개발자가 의도적으로 할당하는 값이 아님)
- null : 값이 비어있음을 명시적으로 나타내기 위해 사용

---

# 비교 연산자

---

# 타입 변환

Falsy한 값

---

# 단축 평가

**&& : 논리곱 연산자**

```js
'A' && 'B' // 'B'
'A' && false // false
false && 'B' // false
```

두 개의 피연산자가 모두 truthy한 값으로 평가되면 true로 평가
-> 논리 연산의 결과를 결정하는 **두 번째 피연산자**를 반환한다.  

**|| : 논리합 연산자**

```js
'A' || 'B' // 'A'
'A' || false // 'A'
false || 'B' // 'B'
```

두 개의 피연산자 중 하나만 truthy한 값으로 평가되어도 true로 평가
-> 논리 연산의 결과를 결정하는 **첫 번째 피연산자**를 반환한다.  

**null 병합 연산자**

```js
const foo = null ?? 'default';
console.log(foo); // 'default'

const bar = '' ?? 'default';
console.log(bar); // ''
```

좌항의 피연산자가 `null` or `undefined` : 우항의 피연산자 반환
(**주의** 좌항의 피연산자가 falsy한 값(false, 0, NaN, "" 등)이어도 그대로 반환된다.) 
`null` or `undefined` 이외 : 좌항의 피연산자 반환  

---

# 객체

## 프로퍼티와 메서드

## 객체 생성 방식

1. 객체 리터럴

```js
const person = {
  name: 'Kim',
  age: 20,
};
```

2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스 (ES6)

## 원시값 vs. 객체

| 원시 타입 | 객체 타입 |
|---|---|---|
| 변경 불가능한 값 | 변경 가능한 값 |
| 변수에 할당하면 실제 값이 저장된다. | 변수에 할당하면 참조값이 저장된다. |
| 값에 의한 전달 발생 <br> 원시값인 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달 | 참조에 의한 전달 발생 <br> 객체를 가리키는 변수를 다른 변수에 할당하면 참조값이 복사되어 전달 |

```js
let score = 100;
let copy = score;
console.log(copy); // 100

score = 50;
console.log(copy); // 100
```

**객체가 변경 가능한 값으로 설계된 이유**
- 객체는 원시값처럼 크기가 일정하지 않아 복사해서 생성하는 비용이 많이 든다. 즉, 메모리를 효율적으로 사용하기 어렵다.
- 따라서 객체는 변경 가능한 값으로 설계되었고, 이로 인해 여러 개의 식별자가 하나의 객체를 공유한다는 구조적인 단점을 안고 있다.

참조에 의한 전달의 부작용
- 예상치 못한 부수효과가 발생한다.

해결 방법 : 객체를 불변 객체로 만들어서 사용한다.  깊은 복사 (Deep Copy)

---

# 함수 

객체와 함수의 차이점 : 호출 가능 여부

자바스크립트의 함수는 일급 객체이다.
따라서 고차함수를 만들거나 콜백할 수 있다. 

**일급 객체** : 아래 조건을 만족하는 객체
1. 변수에 담을 수 있다. 
  ```js
  const foo = function (a, b) {
    return a, b
  };
  ```
2. 매개변수로 전달 가능하다.
  ```js
  function foo = function (num) {
    return num*num
  }
  
  function bar (func, number) {
    return func(number)
  }

  console.log(foo, 2); // 4
  ```
3. 반환값으로 리턴될 수 있다. 
  ```js
  function add(item1) {
    return function (item2) {
      return item1 + item2;
    }
  }

  add(1)(2); // 3
  ```

## 함수 정의 방법
1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수


## 순수 함수와 비순수 함수

## 함수형 프로그래밍
순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이
---

# 참조

- 모던 자바스크립트 Deep Dive (저자 : 이웅모)
