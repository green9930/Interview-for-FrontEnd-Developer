# Index

[1. 자바스크립트란](#자바스크립트란)  
[2. 변수 (variable)](#변수-variable)  
[3. 데이터 타입](#데이터-타입)  
[4. 단축 평가](#단축-평가)
[5. 객체](#객체)
[6. 함수](#함수)
[7. 스코프](#스코프)

---

# 자바스크립트란

## 자바스크립트 렌더링

HTML, CSS, JavaScript등 문서를 해석해서 브라우저에 시각적으로 출력하는 것

### 서버 사이드 렌더링 (Server Side Rendering)

요청을 받으면 서버에서 요청받은 페이지의 HTML 파일을 렌더링한 뒤 이용자에게 반환하는 방식

- 장점

  1. SEO(Search Engine Optimization, 검색엔진 최적화)가 가능하다.
  2. 사용자가 보는 페이지만 렌더링해서 전달하기 때문에 초기 로딩 속도가 CSR에 비해 빠르다.

- 단점
  1. 페이지를 이동할 때마다 요청을 보내고 서버는 해당 페이지 전체를 렌더링하기 때문에 트래픽이 증가한다.
  2. 페이지 이동 시 화면이 깜빡거리는 문제가 있다.
  3. 프로젝트의 복잡도가 증가한다.

### 클라이언트 사이드 렌더링 (Client Side Rendering)

최초 요청을 받으면 서버에서 전체 페이지를 로딩해서 반환하는 방식

- 장점

  1. 최초 요청 이후 서버에 재요청 없이 DOM 조작으로 필요한 부분만 받기 때문에 빠른 인터렉션이 가능하다.

- 단점
  1. 최초 요청 시 모든 페이지를 받기 때문에 첫 로딩 속도가 느리다.
  2. 검색 엔진은 자바스크립트를 실행하지 않기 때문에 브라우저의 검색 엔진 시점에서 SPA의 페이지는 비어있는 상태이다. 따라서 SEO 문제가 발생한다.

## 자바스크립트와 Ajax

**Ajax** : (Asynchronous JavaScript And XML)

- 자바스크립트로 서버와 클라이언트가 비동기적으로 데이터를 전송하고 화면을 구현하는 방식
- 웹페이지에서 변경이 불필요한 부분을 제외하고 서버로부터 필요한 데이터만 전달받아 리렌더링 된다.
- 기존에는 완전한 HTML 코드를 서버로부터 전송받아 웹페이지 전체를 렌더링하는 방식으로 작동했다. 따라서 HTML 코드 일부가 수정되면 변경되지 않은 부분까지 모두 리렌더링되는 비효율적인 측면이 있었고, Ajax를 통해 이 단점을 보완할 수 있었다.

## V8 자바스크립트 엔진

- V8 자바스크립트 엔진의 등장으로 브라우저에서 자바스크립트 코드를 빠르게 실행할 수 있게 되었고 이로 인해 과거 웹 서버에서 수행되던 로직의 다수가 브라우저로 이동하면서 프론트엔드 영역이 주목받는 계기가 되었다.

## ECMAScript

## 자바스크립트의 특징

- 자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍 언어
- 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어 (interpreter language)
  - 인터프리터 언어 : 코드가 실행되는 런타임에 한 줄씩 바이트코드로 변환하여 실행
- 명령형(imperactive), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**
  - 명령형 : "무엇을 어떻게(how) 할 것인가"

## 라이브러리를 사용하는 이유

- 라이브러리가 DOM 엘리먼트를 관리해주기 때문에 개발자는 상태관리(=기능 개발)에만 집중할 수 있다.

## 리액트를 사용하는 이유

컴포넌트 단위로 구성 -> 컴포넌트 일괄 수정
유지보수, 생산성 용이
JSX를 제공하기 때문 : HTML을 알아도
Virtual DOM : 리액트에서 가장 성공적으로 적용

---

# 변수 (variable)

## 변수란 무엇인가? 왜 필요한가?

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름 (값의 위치를 가리키는 상징적인 이름)
- 저장된 값은 메모리 공간에 저장되고, 이를 재사용하기 위해 메모리 공간에 사람이 이해할 수 있는 언어로 상징적인 이름을 붙인 것이 변수이다.

## 변수 선언(variable declaration) 이란?

- 변수 선언 : 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간 주소를 연결해서 값을 저장할 수 있도록 준비하는 것
- 변수는 메모리에 저장된 **값**이 아니라 **메모리 주소**를 기억한다.

## 변수 선언 방식

### var

```js
var result;
```

- ES6 이전 변수 선언 방식
- 변수 선언만 할 경우 자바스크립트 엔진은 확보된 메모리 공간에 `undefined`를 암묵적으로 할당하여 초기화한다.
- 단점 :

  1. 블록 레벨 스코프가 아닌 함수 레벨 스코프를 지원 -> 전역 변수가 남발될 가능성이 커진다.
  2. 변수의 중복 선언이 허용된다.

  ```js
  var x = 1;
  var y = 2;

  // 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.
  var x = 10;
  // 단, 초기화문이 없는 변수 선언문은 무시되며 에러는 발생하지 않는다.
  var y;

  console.log(x); // 10
  console.log(y); // 1
  ```

  -> 동일한 이름의 변수가 선언된 것을 모르고 중복 선언하며 값이 할당되면 의도치 않게 이미 선언된 변수 값이 변경되는 부작용이 발생한다. 
  3. 변수 호이스팅 발생 : 코드 가독성을 떨어트리고 오류 발생의 여지가 있다.

**변수 호이스팅**

```js
console.log(result); // undefined
var result;
result = 10;
console.log(result); // 10
```

- 호이스팅 : 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

변수 호이스팅은 왜 발생할까?

- 자바스크립트는 런타임 이전에 코드를 평가하는 과정을 거친다. 이 과정에서 변수 선언이 먼저 평가되고, var 키워드의 경우 변수 선언과 초기화가 동시에 이루어지기 때문에 런타임에 `console.log(result)`에서 `undefined`가 출력되는 것이다.

### let

- ES6 이후 등장한 변수 선언 방식

### const

- 단 한 번만 할당할 수 있는 변수, 즉 상수를 선언하는 키워드 (단, 항상 상수를 선언하기 위해 사용되는 것은 아니다.)
- const 키워드로 선언된 변수는 재할당이 금지된다. (불변(immutable)을 의미하는 것이 아니다.)
  - 변수에 원시값을 할당한 경우, 할당된 값을 변경할 수 있는 방법이 없으므로 프로그램의 유지보수성이 대폭 향상된다.
  - 변수에 객체를 할당한 경우, 값을 변경할 수 있다.
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

  ```js
  const foo = 1;
  const bar; // SyntaxError: Missing initializer in const declaration
  ```

**var vs. let/const**

1. 스코프 내부 중복 선언

- var 키워드는 동일한 스코프 내부에서 중복선언이 허용된다.
  -> 자바스크립트 엔진이 var 키워드가 없는 것처럼 동작하여 의도치 않게 변수값이 재할당되어 변경되는 부작용을 낳는다.
- let과 const는 동일 스코프 내부에서 중복선언이 불가능하다. (SyntaxError 발생)

```js
function foo() {
  var a = 1;
  var a = 2;

  console.log(a); // 2
}

foo();
```

```js
function foo() {
  let a = 1;
  let a = 2;

  console.log(a); // SyntaxError: Identifier 'a' has already been declared
}

foo();
```

2. 변수 호이스팅

- var 키워드는 선언 단계와 초기화 단계가 코드 평가단계에서 실행된다. 따라서 변수 선언문 이전에 참조하면 `undefined`가 반환된다.
- let 키워드는 선언 단계와 초기화 단계가 분리되어 있다. (일시적 사각지대(Temporal Dead Zone) 발생) 띠라서 변수 선언문 이전에 참조하면 ReferenceError가 발생한다.


3. 전역 객체

- var 키워드로 선언한 전역 변수, 전역 함수, 암묵적 전역은 전역 객체 window의 프로퍼티가 된다.
- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.

```js
var x = 1;
function foo() {}
y = 2;

console.log(window.x); // 1
console.log(window.y); // 2
console.log(window.foo); // function foo() {}

let a = 1;

console.log(window.a); // undefined
console.log(a); // 1
```

## 전역 변수의 문제점

**변수의 생명주기** : 메모리 공간이 확보(allocate)된 시점 ~ 메모리 공간이 해제(release)되어 가용 메모리 풀(memory pool)에 반환되는 시점

변수는 생명주기가 있어 자신이 선언된 위치에서 생성되고 소멸한다.
함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되어 함수 실행이 종료되었을 때 소멸한다.
그러나 전역 변수의 생명 주기는 애플리게이션의 생명 주기와 동일하다.

### 문제점

1. 암묵적 결합

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용한다. 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

2. 긴 생명 주기

- 전역 변수는 생명 주기가 길기 때문에 메모리 소비량도 크고 상태 변경에 의한 오류 발생 가능성이 높다.

3. 스코프 체인 상 종점에 존재

- 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다. (= 전역 변수의 검색 속도가 가장 느리다.)

4. 네임스페이스 오염

- 자바스크립트는 파일이 분리되어 있더라도 하나의 전역 스코프를 공유하기 때문에 동일한 이름의 전역 변수나 전역 함수가 존재할 경우 예상치 못한 결과를 가져올 수 있다.

### 전역 변수 사용을 억제하는 방법

**변수의 스코프는 좁을수록 좋다.** 꼭 필요한 이유가 없다면 지역 변수를 사용하고 무분별한 전역 변수의 남발을 억제해야 한다.

1. 즉시 실행 함수

- 즉시 실행 함수는 함수 정의와 동시에 호출된다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```js
(function () {
  let foo = 100;
})();

console.log(foo); // ReferenceError: foo is not defined
```

2. 네임스페이스 객체

- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
  (네임 스페이스 : 개체를 구분할 수 있는 범위를 나타냄. 하나의 네임 스페이스에는 하나의 이름이 단 하나의 개체만을 가리킨다.)
- 단, 네임스페이스 객체 자체가 전역 변수에 할당되므로 권장되진 않는다.

  ```js
  const NAME = {};
  NAME.name = "Kim";

  console.log(NAME.name);
  ```

3. 캡슐화와 정보은닉

- 캡슐화 : 클로저를 기반으로 관련된 변수와 함수를 하나의 모듈로 만드는 방법
- 정보은닉 : 객체의 특정 프로퍼티나 메서드를 감출 목적으로 캡슐화하는 것

4. ES6 모듈

- ES6 모듈을 사용하면 전역 변수를 사용할 수 없다.
- 파일 자체의 독자적인 모듈 스코프 제공. 모듈 내에서 선언된 변수는 전역 변수도 아니고 window 객체의 프로퍼티도 아니다.
- 잘 사용하지 않는 이유
  - 구형 브라우저에서 동작하지 않으며, ES6 모듈을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에  Webpack 등의 모듈 번들러를 사용하는 것이 일반적

## 가비지 콜렉터

가비지 콜렉터의 알고리즘 : **Mark and Sweep algorithm**
자바스크립트는 managed language (C언어등은 unmanaged language : 개발자가 직접 메모리를 해제해야 한다.)

1. Mark phase

- GC Root(가비지 콜렉터의 루트)로부터 시작해 이 루트가 참조하는 모든 오브젝트를 마크한다.

2. Sweep phase

- 마크가 끝나면 가비지 콜렉터는 메모리 전체를 돌면서 마크되지 않은 메모리를 해제한다.

---

# 데이터 타입

## 데이터 타입의 종류 (자료형)

- 원시 타입 (primitive type)
  1. 숫자 타입
  - 다른 언어는 다양한 숫자타입이 있으나 자바스크립트는 number 하나만 존재한다. (모든 수를 실수로 처리한다.)
  2. 문자열 타입
  3. 불리언 타입
  4. undefined 타입
  5. null 타입
  6. symbol 타입

7. 객체 타입 : 객체, 함수, 배열 등

**undefined와 null의 차이점**

- undefined : 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값 (개발자가 의도적으로 할당하는 값이 아님)
- null : 값이 비어있음을 명시적으로 나타내기 위해 사용

---

# 비교 연산자

---

# 타입 변환

## 명시적 타입 변환

명시적 타입 변환 (explicit coercion) / 타입 캐스팅 (type casting) : 개발자가 의도를 갖고 다른 타입으로 변환
- 문자열 타입으로 변환하는 방법
  1. String 생성자 함수를 new 연산자 없이 호출
  2. Object.prototype.toString 메서드 사용
  3. 문자열 연결 연산자 사용

- 숫자 타입으로 변환하는 방법
  1. Number 생성자 함수를 new 연산자 없이 호출
  2. parseInt, parseFloat 함수 사용(문자열만 변환 가능)
  3. `+` 연산자 이용
  4. `*` 연산자 이용

- 불리언 타입으로 변환하는 방법
  1. Boolean 생성자 함수를 new 연산자 없이 호출
  2. ! 부정 논리 연산자를 두 번 사용

## 암묵적 타입 변환

암묵적 타입 변환 (implicit coercion) / 타입 강제 변환 (type coercion) : 개발자의 의도와 무관하게 자바스크립트 엔진에 의해 암묵적으로 타입 변환
- 암묵적 타입 변환의 종류
  1. 문자열 타입으로 변환
  2. 숫자 타입으로 변환
  3. 불리언 타입으로 변환

## false로 평가되는 값

- false
- undefined
- null
- 0, -0
- NaN
- '' (빈 문자열)

## 단축 평가

**&& : 논리곱 연산자**

```js
"A" && "B"; // 'B'
"A" && false; // false
false && "B"; // false
```

두 개의 피연산자가 모두 truthy한 값으로 평가되면 true로 평가
-> 논리 연산의 결과를 결정하는 **두 번째 피연산자**를 반환한다.

**|| : 논리합 연산자**

```js
"A" || "B"; // 'A'
"A" || false; // 'A'
false || "B"; // 'B'
```

두 개의 피연산자 중 하나만 truthy한 값으로 평가되어도 true로 평가
-> 논리 연산의 결과를 결정하는 **첫 번째 피연산자**를 반환한다.

**null 병합 연산자(??)**

```js
const foo = null ?? "default";
console.log(foo); // 'default'

const bar = "" ?? "default";
console.log(bar); // ''
```

좌항의 피연산자가 `null` or `undefined` : 우항의 피연산자 반환
(**주의** 좌항의 피연산자가 falsy한 값(false, 0, NaN, "" 등)이어도 그대로 반환된다.)
`null` or `undefined` 이외 : 좌항의 피연산자 반환
기본값 설정할 때 자주 사용한다. 

**옵셔널 체이닝 연산자(?.)**

```js
const elem = null;

const value = elem?.value;
console.log(value); // undefined
```

좌항의 피연산자가 `null` 또는 `undefined인` : `undefined` 반환
`null` or `undefined` 이외 : 우항의 프로퍼티 참조

---

# 객체

## 프로퍼티와 메서드

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

## 객체 생성 방식

1. 객체 리터럴

  ```js
  const person = {
    name: "Kim",
    age: 20,
  };
  ```
2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스 (ES6)

## 원시값 vs. 객체

| 원시 타입                                                  | 객체 타입                                                   |
|--------------------------------------------------------|---------------------------------------------------------|
| 변경 불가능한 값                                              | 변경 가능한 값                                                |
| 변수에 할당하면 실제 값이 저장된다.                                   | 변수에 할당하면 참조값이 저장된다.                                     |
| 값에 의한 전달 발생 <br> 원시값인 변수를 다른 변수에 할당하면 원본의 원시값이 복사되어 전달 | 참조에 의한 전달 발생 <br> 객체를 가리키는 변수를 다른 변수에 할당하면 참조값이 복사되어 전달 |

```js
let score = 100;
let copy = score;
console.log(copy); // 100

score = 50;
console.log(copy); // 100
```

**객체가 변경 가능한 값으로 설계된 이유**

- 객체는 원시값처럼 크기가 일정하지 않아 복사해서 생성하는 비용이 많이 든다. 즉, 메모리를 효율적으로 사용하기 어렵다.
- 따라서 객체는 변경 가능한 값으로 설계되었고, 이로 인해 여러 개의 식별자가 하나의 객체를 공유한다는 구조적인 단점을 안고 있다.

참조에 의한 전달의 부작용

- 예상치 못한 부수효과가 발생한다.

해결 방법 : 객체를 불변 객체로 만들어서 사용한다. 깊은 복사 (Deep Copy)

---

# 함수

객체와 함수의 차이점 : 호출 가능 여부

자바스크립트의 함수는 일급 객체이다.
따라서 고차함수를 만들거나 콜백할 수 있다.

**일급 객체** : 아래 조건을 만족하는 객체

1. 변수에 담을 수 있다.

```js
const foo = function (a, b) {
  return a, b;
};
```

2. 매개변수로 전달 가능하다.

```js
function foo = function (num) {
  return num*num
}

function bar (func, number) {
  return func(number)
}

console.log(foo, 2); // 4
```

3. 반환값으로 리턴될 수 있다.

```js
function add(item1) {
  return function (item2) {
    return item1 + item2;
  };
}

add(1)(2); // 3
```

## 함수 정의 방법

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수

## 순수 함수와 비순수 함수

- 순수 함수 : 동일한 입력에 동일한 출력을 반환하며 side effect가 없는 함수
- 비순수 함수 :

## 함수형 프로그래밍

순수 함수를 통해 부수 효과를 최대한 억제해 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임

---

# 스코프

## 개념

**스코프** : (scope) 식별자의 유효 범위

모든 식별자는 자신이 선언된 위치에 의해 스코프가 결정된다.

## 종류

| 구분     | 내용                                            | 변수    |
|--------|-----------------------------------------------|-------|
| 전역 스코프 | 코드의 가장 바깥 영역 <br>\*어디서든 참조 가능                 | 전역 변수 |
| 지역 스포크 | 함수 몸체(지역) 내부 <br>\*자신의 지역 스코프와 하위 지역 스코프에서 유효 | 지역 변수 |

## 스코프 체인

함수는 중첩될 수 있으므로 스코프 또한 함수의 중첩에 의해 계층적 구조를 가질 수 있다.

- 스코프 체인 : (scope chain) 계층적으로 연결된 단방향 링크드 리스트 스코프의 구조 
- 중첩 함수 : (nested function) 함수 몸체 내부에서 정의된 함수
- 외부 함수 : (outer function) 중첩 함수를 포함하는 함수

**스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다.**

자바스크립트 엔진은 변수를 참조할 때 변수를 참조하는 코드의 스코프부터 스코프 체인을 통해 상위 스코프 방향으로 이동한다.
따라서 상위 스코프에서 유효한 변수는 하위 스코프에서 참조 가능하나, 하위 스코프에서 유효한 변수를 상위 스코프에서는 참조할 수 없다.  
*스코프 체인 최상위 스코프 : 전역 스코프

```js
function foo() {
  console.log("global");
}

function bar() {
  function foo() {
    console.log("local");
  }

  foo();
}

bar(); // local
```

## 함수 레벨 스코프 vs. 블록 레벨 스코프

- 함수 레벨 스코프 : (function level scope) 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정
  - var 키워드
- 블록 레벨 스코프 : (block level scope) 모든 코드 블록(if, for, while, try/catch 등)을 지역 스코프로 인정
  - let, const, 대부분의 프로그래밍 언어(C, java 등)

```js
var a = 1;

if (true) {
  var a = 10;
}

console.log(a); // 10
```

```js
let a = 1;

if (true) {
  let a = 10;
}

console.log(a); // 1
```

## 렉시컬 스코프

**상위 스코프 결정 방식**

1. 함수를 어디서 "호출"했는지에 따라 함수의 상위 스코프 결정

  - 동적 스코프(dynamic scope)
  - 함수가 호출되는 시점에 동적으로 상위 스코프가 결정된다.

2. 함수를 어디서 "정의"했는지에 따라 함수의 상위 스코프 결정

  - 렉시컬 스코프(lexical scope) or 정적 스코프(static scope)
  - 함수 정의가 평가되는 시점에 상위 스코프가 결정된다.
  - 자바스크립트를 포함한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다. (렉시컬 체인은 물리적으로 실재한다.)

자바스크립트 함수의 상위 스코프는 언제나 **자신이 정의된 스코프**를 기준으로 정의된다.
함수 정의(함수 선언문 or 함수 표현식)가 실행되어 생성된 함수 객체는 자신이 결정된 상위 스코프를 기억한다. (함수가 호출될 때마다 상위 스코프를 참조해야 하기 때문)

```js
let a = 1;

function foo() {
  let a = 2;
  bar();
}

function bar() {
  console.log(a);
}

foo(); // 1
bar(); // 1
```

---

# 프로퍼티 어트리뷰트

## 내부 슬롯과 내부 메서드

- 자바스크립트 엔진의 내부 로직으로 개발자가 직접 접근할 수 있도록 공개되진 않았다. 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근 가능한 수단을 제공한다.
  ```js
  const o = {};
  o[[Prototype]]; // -> Uncaught SyntaxError: Unexpected token '['
  o.__proto__; // -> Object.prototype
  ```

## 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

## 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티 : 키와 값으로 구성된 일반적인 프로퍼티
  | 프로퍼티 어트리뷰트         | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                             |
  |--------------------|---------------------|--------------------------------|
  | `[[Value]]`        | value               | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값 |
  | `[[Writable]] `    | writable            | 프로퍼티 값의 변경 가능 여부를 나타내는 불리언 값   |
  | `[[Enumerable]]`   | enumerable          | 프로퍼티의 열거 가능 여부를 나타내는 불리언 값     |
  | `[[Configurable]]` | configurable        | 프로퍼티의 재정의 가능 여부를 나타내는 불리언 값    |

- 접근자 프로퍼티 : 자체적으로는 값을 갖지 앉고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수(accessor function)로 구성된 프로퍼티

| 프로퍼티 어트리뷰트         | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                                                        |
|--------------------|---------------------|---------------------------------------------------------------------------------------------------------------------------|
| `[[Get]]`          | get                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수 <br> 프로퍼티 키로 프로퍼티 값에 접근하면 getter 함수(`[[Get]]`의 값)가 호출되고 그 결과가 프로퍼티 값으로 반환      |
| `[[Set]]`          | set                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수 <br> 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 setter 함수(`[[Set]]`의 값)가 호출되고 그 결과가 프로퍼티 값으로 저장 |
| `[[Enumerable]]`   | enumerable          | 데이터 프로퍼티의 `[[Enumerable]]`과 동일                                                                                            |
| `[[Configurable]]` | configurable        | 데이터 프로퍼티의 `[[Configurable]]`과 동일                                                                                          |

---

# 참조

- 모던 자바스크립트 Deep Dive (저자 : 이웅모)
